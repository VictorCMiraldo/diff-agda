===========================================================================
                           ICFP 2016 Review #45B
---------------------------------------------------------------------------
                Paper #45: Structure-aware version control
---------------------------------------------------------------------------

                      Overall merit: C. Weak paper, though I will not fight
                                        strongly against it
                         Confidence: X. I am an expert in this area

                         ===== Paper summary =====

This paper presents a generic approach to version control over any structure
(type), all implemented and verified in Agda.

                      ===== Comments for author =====

The motivation behind the paper is nice: Too many programming errors have
happened as a result of line-based version control systems. 

My main concern with this paper is that it does not properly state the
requirements on what a patch is, before defining what a patch is according to
the authors. 

In my opinion, the authors have missed three important properties that patches
should have:

(1) they should be minimal; in fact, the authors explicitly deviate from this
requirement by saying they would rather have a cost model that "more accurately
captures which changes are important", without giving a formal definition of
what is "important".

Minimality is good, because it excludes trivial solutions. If I want to
characterize changes from a version A to a version B, I may just record B, "the
new version". If there is no requirement restricting the amount of information a
patch can have, it is hard to say anything about it. (Or indeed to prove
properties about it.)

(2) they should be compact; for patches to be dealt with and stored,
communicated, etc. separately from the actual document, they should be small in
size for small changes. From what I can see from the paper, your patches are as
big as the actual tree (minus the information in the leaves). This seems
extremely impractical.

(3) they should be efficiently computable; you don't even state what the
complexity is of computing patches, but your definition is triply-recursive.
Perhaps this does not matter for a prototype, but there should at least be a
chance of implementing patches efficiently. Can this be done? Does memoization
work (as it does for the diff3 algorithm?)

If you find (1) too much, here are some sanity checks I would like to see on patches.

Most version control systems control trees (of files). What happens to your
patches if you would apply them on the whole tree of documents? Do you mimic
what you would expect to happen? (My guess is that they don't, because of (1)
and (2) above.)

What would happen if we used your notion of patch on the structured data we edit
the most, namely programs? Does your notion of patch make sense? If not, why
not, and why should we care about your notion of patch? If so, please add it to
the paper.

General comments:

I think it is a mistake to mix the type-generic presentation with your concept
of patches over trees. The reader is drowning in Agda an type details before
they even have a chance to understand what you want to do. I think it is a good
idea to first present your ideas on the following concrete datatype:

data Tree = Nil | Node Tree Tree

it has everything!

Detailed comments:

Intro: "a cost model one" --> remove "one"

"works accurately manages" --> ?

Why do you use bits as leafs and not, say, words?

Section 2: "to make life easier" --> than what?

The order of constructors in the grammar and the datatype is not the same.

"occurs in" --> "occur in"

Why is Move not an operation?

"good advantage" --> there are no bad advantages

Explain better why arity cannot be defined like that

"familiar operations to copy a value" -- no, not familiar

Explain the difference between [11] and what you do.

"Remember that we ... metric" - remember? you never told us

Why is it important to be a metric?

Section 3: "... define two patches to be aligned .. a just" - this is a circular
definition of alignedness. What if I decide for no patches to be aligned?

How do you report a conflict with result type Maybe (Patch t ty)?

a overlap --> an

Sect. 5: "On this paper" --> in

"demonstrating the viability" --> how so? (what does this even mean?)

"to our" --> ours

"...proofs much harder" --> harder than what?
